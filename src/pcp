#!/usr/bin/env perl
#
# Copyright (c) 2013 andrew@ardnew.com
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this 
# software and associated documentation files (the "Software"), to deal in the Software 
# without restriction, including without limitation the rights to use, copy, modify, 
# merge, publish, distribute, sublicense, and/or sell copies of the Software, and to 
# permit persons to whom the Software is furnished to do so, subject to the following 
# conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or
# substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
# PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
# OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR 
# OTHER DEALINGS IN THE SOFTWARE.
#
package pcp;


####[ pragmas ]###########################################################################


use strict;
use warnings;
use diagnostics;


####[ constants ]#########################################################################


my $PNAME = __PACKAGE__;

my $PVERS = '__PCPVERS__'; # package version
my $PDATE = '__PCPDATE__'; # package date and time
my $PVSTR = sprintf "%s version %s, %s", $PNAME, $PVERS, $PDATE;

my $GINFO = 0; # "general" message level
my $NOTIC = 1; # "notice" (only prints if -v)
my $WARNG = 2; # "warning"
my $ERROR = 3; # "error"

my $FTYPE = 0; # "file"
my $DTYPE = 1; # "directory"

my $OPTMO = 0; # optional module
my $REQMO = 1; # required module

my $ALLOK = 0; # good
my $ONOES = 1; # bad

my $INVAL = -1; # invalid

my $DEENC = 'hex'; # default encoding for checksum output 
my ($CKSUM, $ENCOD, $HALGO) = 0 .. 2;

my $PROGS = '='; # symbol used to represent each step of the progress bar

my $PCTGW = 6; # width of the percentage string  e.g. "[ 42%]" (chars)
my $PBARW = 4; # minimum width required for progress bar e.g. "[**]" (chars)

my $DEFTW = 60; # default terminal width if we can't find one from the system

my $DEFTH = 'lowtide';
my $LSCOL = 'list'; # the -o option value used to show available themes

my $RESET = "\e[0m"; # ANSI text reset

my %COLOR =
(
  RESET       => sub { $RESET.(shift).$RESET },
  # regular
  BLACK       => sub { "\e[0;30m".(shift) }, # black
  RED         => sub { "\e[0;31m".(shift) }, # red
  GREEN       => sub { "\e[0;32m".(shift) }, # green
  YELLOW      => sub { "\e[0;33m".(shift) }, # yellow
  BLUE        => sub { "\e[0;34m".(shift) }, # blue
  PURPLE      => sub { "\e[0;35m".(shift) }, # purple
  CYAN        => sub { "\e[0;36m".(shift) }, # cyan
  WHITE       => sub { "\e[0;37m".(shift) }, # white
  # bold
  BBLACK      => sub { "\e[1;30m".(shift) }, # black
  BRED        => sub { "\e[1;31m".(shift) }, # red
  BGREEN      => sub { "\e[1;32m".(shift) }, # green
  BYELLOW     => sub { "\e[1;33m".(shift) }, # yellow
  BBLUE       => sub { "\e[1;34m".(shift) }, # blue
  BPURPLE     => sub { "\e[1;35m".(shift) }, # purple
  BCYAN       => sub { "\e[1;36m".(shift) }, # cyan
  BWHITE      => sub { "\e[1;37m".(shift) }, # white
  # underline
  UBLACK      => sub { "\e[4;30m".(shift) }, # black
  URED        => sub { "\e[4;31m".(shift) }, # red
  UGREEN      => sub { "\e[4;32m".(shift) }, # green
  UYELLOW     => sub { "\e[4;33m".(shift) }, # yellow
  UBLUE       => sub { "\e[4;34m".(shift) }, # blue
  UPURPLE     => sub { "\e[4;35m".(shift) }, # purple
  UCYAN       => sub { "\e[4;36m".(shift) }, # cyan
  UWHITE      => sub { "\e[4;37m".(shift) }, # white
  # background
  ON_BLACK    => sub { "\e[40m".(shift) }, # black
  ON_RED      => sub { "\e[41m".(shift) }, # red
  ON_GREEN    => sub { "\e[42m".(shift) }, # green
  ON_YELLOW   => sub { "\e[43m".(shift) }, # yellow
  ON_BLUE     => sub { "\e[44m".(shift) }, # blue
  ON_PURPLE   => sub { "\e[45m".(shift) }, # purple
  ON_CYAN     => sub { "\e[46m".(shift) }, # cyan
  ON_WHITE    => sub { "\e[47m".(shift) }, # white
  # high-intensity
  IBLACK      => sub { "\e[0;90m".(shift) }, # black
  IRED        => sub { "\e[0;91m".(shift) }, # red
  IGREEN      => sub { "\e[0;92m".(shift) }, # green
  IYELLOW     => sub { "\e[0;93m".(shift) }, # yellow
  IBLUE       => sub { "\e[0;94m".(shift) }, # blue
  IPURPLE     => sub { "\e[0;95m".(shift) }, # purple
  ICYAN       => sub { "\e[0;96m".(shift) }, # cyan
  IWHITE      => sub { "\e[0;97m".(shift) }, # white
  # bold high-intensity
  BIBLACK     => sub { "\e[1;90m".(shift) }, # black
  BIRED       => sub { "\e[1;91m".(shift) }, # red
  BIGREEN     => sub { "\e[1;92m".(shift) }, # green
  BIYELLOW    => sub { "\e[1;93m".(shift) }, # yellow
  BIBLUE      => sub { "\e[1;94m".(shift) }, # blue
  BIPURPLE    => sub { "\e[1;95m".(shift) }, # purple
  BICYAN      => sub { "\e[1;96m".(shift) }, # cyan
  BIWHITE     => sub { "\e[1;97m".(shift) }, # white
  # high-intensity background
  ON_IBLACK   => sub { "\e[0;100m".(shift) }, # black
  ON_IRED     => sub { "\e[0;101m".(shift) }, # red
  ON_IGREEN   => sub { "\e[0;102m".(shift) }, # green
  ON_IYELLOW  => sub { "\e[0;103m".(shift) }, # yellow
  ON_IBLUE    => sub { "\e[0;104m".(shift) }, # blue
  ON_IPURPLE  => sub { "\e[10;95m".(shift) }, # purple
  ON_ICYAN    => sub { "\e[0;106m".(shift) }, # cyan
  ON_IWHITE   => sub { "\e[0;107m".(shift) }, # white
);

my %THEME = 
(
  hightide => 
  {
    header => { fg => "WHITE", bg => undef },
    detail => { fg => "CYAN",  bg => undef },
    symbol => { fg => "ICYAN", bg => undef },
  }, 
  lowtide =>
  {
    header => { fg => "ICYAN", bg => undef },
    detail => { fg => "WHITE", bg => undef },
    symbol => { fg => "CYAN",  bg => undef },
  },
  flashgordon =>
  {
    header => { fg => "IYELLOW", bg => undef },
    detail => { fg => "RED",     bg => undef },
    symbol => { fg => "YELLOW",  bg => undef },
  },
  gashflordon =>
  {
    header => { fg => "IRED",  bg => undef },
    detail => { fg => "IYELLOW", bg => undef },
    symbol => { fg => "RED",    bg => undef },
  },    
  black => 
  {
    header => { fg => "IBLACK", bg => undef },
    detail => { fg => "BLACK",  bg => undef },
    symbol => { fg => "IBLACK", bg => undef },
  },
  red => 
  {
    header => { fg => "IRED", bg => undef },
    detail => { fg => "RED",  bg => undef },
    symbol => { fg => "IRED", bg => undef },
  },
  green => 
  {
    header => { fg => "IGREEN", bg => undef },
    detail => { fg => "GREEN",  bg => undef },
    symbol => { fg => "IGREEN", bg => undef },
  },
  yellow => 
  {
    header => { fg => "IYELLOW", bg => undef },
    detail => { fg => "YELLOW",  bg => undef },
    symbol => { fg => "IYELLOW", bg => undef },
  },
  blue => 
  {
    header => { fg => "IBLUE", bg => undef },
    detail => { fg => "BLUE",  bg => undef },
    symbol => { fg => "IBLUE", bg => undef },
  },
  purple => 
  {
    header => { fg => "IPURPLE", bg => undef },
    detail => { fg => "PURPLE",  bg => undef },
    symbol => { fg => "IPURPLE", bg => undef },
  },
  cyan => 
  {
    header => { fg => "ICYAN", bg => undef },
    detail => { fg => "CYAN",  bg => undef },
    symbol => { fg => "ICYAN", bg => undef },
  },
  white => 
  {
    header => { fg => "IWHITE", bg => undef },
    detail => { fg => "WHITE",  bg => undef },
    symbol => { fg => "IWHITE", bg => undef },
  },
);

my @STATT = 
(
  'dev', # device number of filesystem
  'ino', # inode number
  'mod', # file mode (type and permissions)
  'nhl', # number of (hard) links to the file
  'uid', # numeric user ID of file's owner
  'gid', # numeric group ID of file's owner
  'did', # device identifier (special files only)
  'siz', # total size of file in bytes
  'act', # last access time in seconds since epoch
  'mdt', # last modify time in seconds since epoch
  'cgt', # inode change time in seconds since epoch
  'bsz', # preferred I/O size in bytes
  'blk', # actual number of blocks allocated
);
my %STATN = map { $_ => $.++ } @STATT;

my ($VOLIX, $DIRIX, $FILIX) = 0 .. 2; # indices for returned File::Spec->splitpath list

my %ENCOD =
(
  bin => 'binary',
  hex => 'hexadecimal',
  b64 => 'Base64',
);


####[ globals ]###########################################################################


our $bitbucket = undef; # the system null device remains undef until we load File::Spec
our $defbuff = 512000; # default I/O byte buffer size

my %bootstrp_module = # these modules are needed for bootstrapping other features
(
  'Getopt::Long'    => [ qw[] ],
  'Pod::Usage'      => [ qw[] ],  
);

my %required_module =
(
  'File::Spec'      => [ qw[ :all ] ],
  'File::Path'      => [ qw[] ],
  'File::Find'      => [ qw[] ],
  'Time::HiRes'     => [ qw[ gettimeofday tv_interval ] ],  
);

my %optional_module =
(
  'POSIX'           => [ qw[] ],
  'Term::ReadKey'   => [ qw[] ],
  'Benchmark'       => [ qw[ cmpthese ] ],
  'Digest::MD5'     => [ qw[] ],
  'Digest::SHA'     => [ qw[] ],
);

my %option =
(
  b_buffs => [ qw[                     buffer|b=i   ], $defbuff ],
  c_cksum => [ qw[                   checksum|c=s           0 ] ], # 0 is "default value"
  d_depth => [ qw[                      depth|d=i          -1 ] ],  
  f_force => [ qw[                      force|f!            1 ] ],
  h_usage => [ qw[    usage|help|what|wat|u|h|?             0 ] ],
  i_inter => [ qw[                interactive|i             0 ] ], 
  m_manpg => [ qw[                manpage|man|m             0 ] ],
  o_color => [ qw[               colors|theme|o=s           0 ] ],
  p_progr => [ qw[                   progress|p!            1 ] ],
  q_quiet => [ qw[                      quiet|q             0 ] ],
  r_cycle => [ qw[                        crc|r=i           0 ] ],
  s_simul => [ qw[                   simulate|s             0 ] ],
  t_bench => [ qw[                       test|t=i           0 ] ],
  v_debug => [ qw[            debug|verbose|d|v+            0 ] ],
  w_width => [ qw[                      width|w=i           0 ] ],
);

my %pod =
(
  usage    => 1,
  manpage  => 2,
);

my %theme = %{$THEME{$DEFTH}};


####[ forward declarations ]##############################################################


#
# initializes the program by pre-loading some modules and parsing command line options
#
sub init;

#
# called when one of the following signals was received: SIGTERM, SIGINT, SIGQUIT, SIGHUP
# 
# this routine calls exit (which gives the interpreter a chance to hit the END block)
#
sub sigtrap;

#
# returns an ANSI colorized string
#
# arg1: string to color
# arg2: foreground/background color hash (see: %theme hash)
#
sub colormebadd ($$);

#
# returns sub colormebadd ($$$) with a trailing ANSI reset sequence
#
sub color ($$);

#
# splits the input string into characters and calls sub colormebadd ($$$) with a random
# color for every character. an ANSI reset sequence is added to the tail
#
sub spectralchars ($);

#
# prints a list of available themes defined in %THEME and exits the program
#
sub show_themes;

#
# accepts a theme name as parameter and configures the global %theme hash accordingly
#
sub set_theme ($);

#
# print a list of messages based on increasing numeric importance level:
#   
#   $GINFO: print a general message regardless of verbosity
#   $NOTIC: print a notice to STDOUT (if -v set) and continue program execution
#   $WARNG: print a warning to STDERR and continue program execution
#   $ERROR: print an error to STDERR and exit program with error code $ONOES
#
# arg1: message importance level
# arg2: list of messages to print (NOTE: if $arg1 is $GINFO or $NOTIC, the first element
#       of @arg2 is interpreted as the prompt title)
#
sub print_message ($@);

#
# attempt to import external Perl modules
#
#   if the module is required and not found, exit program
#   if the module is optional and not found, continue program
#
# for optional modules not found, the corresponding key is deleted from the module hash
# to allow the program to check if it was successfully imported or not:
#
#   exists $module{'Module::Name'} == module loaded
#
# arg1: modules in arg2 are required (no = $OPTMO, yes = $REQMO)
# arg2: hash reference with structure { 'Module::Name' => [ "symbols", "to", "import" ] }
#
sub load_modules ($$);

#
# prints the contents of a module hash. if called after sub load_modules ($$), then
# only the successfully loaded modules will exist and be printed
#
# arg1: modules in arg2 are required (no = $OPTMO, yes = $REQMO)
# arg2: name of the module group, use undef for none
# arg3: hash reference with structure { 'Module::Name' => [ "symbols", "to", "import" ] }
#
sub show_modules ($$$);

#
# calls Getopt::Long::GetOptions with reference to above %option hash, and replaces the
# hash value (the array reference) with the result of GetOptions's parsing
#
# example:
#
#   after the call to parse_options, you can get the parsed debug option value:
#
#     $option{v_debug}
#
#   you will NOT have to (de-)reference the array:
#
#     ${$option{v_debug}}[1]
#
sub parse_options ($);

#
# print the contents of the global %option hash
# 
sub show_options;

#
# performs some pre-processing for optional modules after options have been parsed
# but before any file processing occurs
#
sub configure;

#
# runs pod2usage showing the specified sections and then exits program
#
# arg1: program return code
# arg2: display sections (see %pod hash definition for options)
#
sub pod ($$);

#
# accepts as input a list of length at least 2. the first element of the list is 
# interpreted as TARGET, and all succeding elements are SOURCE
#
# if more than 1 SOURCE exists, TARGET must be a directory. otherwise, both may be
# either a file or a directory
#
# on success, returns the file type of TARGET (FTYPE = file, DTYPE = directory), followed
# by the root directory of the target copy path, and finally a hash structure of all 
# needed copy operations. the { key => val } structure defines each key as a SOURCE path 
# and TARGET as the corresponding target path
#
# on failure, prints an error message and exits the program
#
sub identify_paths (@);

#
# accepts a list of directory paths and attempts to create them
#
# on success, returns silently.
# on failure, prints an error message and exits the program
#
sub create_directories (@);

#
# performs a copy of one file
#
# arg1: source file counter
# arg2: total number of source files
# arg3: source file
# arg4: target file
# arg5: target file type
# arg6: terminal width (in chars), undef if user did not enable option
#
sub copy_file ($$$$$$);

#
# uses Benchmark module to compare timings of sub copy_file with various buffer sizes
#
# arg1: source file counter
# arg2: total number of source files
# arg3: source file
# arg4: target file
# arg5: target file type
# arg6: terminal width (in chars), undef if user did not enable option
#
sub test_buffers ($$$$$$);

#
# accepts the name of an executable as argument, and returns the full path for all
# executables of this name in the user's path. returns the empty list if none found.
#
sub executable_path ($);

#
# walks over the user's PATH looking for a file with the name given in arg1. if found,
# tries to execute the command with the arguments specified by arg2. once that 
# command returns, it verifies the output was something we were expecting by matching
# each line against the regular expression in arg3. returns a list of all matching
# lines, or returns the empty list if nothing matched.
#
# arg1: program/command name
# arg2: arguments for command arg1
# arg3: regular expression (qr//) describing an expected result value format (per line)
#
sub execute_system_program ($$$);

#
# returns the argument passed to --width (if given). otherwise, uses (in order of
# availability): Term::ReadKey, tput, stty, and then $DEFTW
#
sub get_terminal_width;

#
# arg1: bytes written
# arg2: total bytes in file
# arg3: time elapsed since copy began (in microseconds)
# arg4: terminal width (in chars)
# arg5: filehandle for output
# arg6: filename string for file window
# arg7: length of filename in arg6
#
sub show_progress ($$$$$$$);

#
# strings for output details
#
sub header (@);
sub status (@);
sub summary (@);
sub checksum (@);

#
# determines the checksum hash function specified at command line, and returns an array
# reference with structure:
#
#   @[ hash_state_object, encoding, algorithm_name ] 
#
# if no checksum requested, returns undef.
#
# if an invalid function is specified, the program dies with error details. 
#
sub get_hash_function;


####[ main line ]#########################################################################


init;

load_modules $REQMO, \%required_module;
load_modules $OPTMO, \%optional_module;

pod $ALLOK, "manpage" if $option{m_manpg};
pod $ALLOK, "usage" if $option{h_usage};

configure;

my ($fdtype, $tfroot, %cppath) = identify_paths reverse @ARGV;

my @tdpath = map { $cppath{$_} } grep { -d } keys %cppath;
my @tfpath = grep { -f } keys %cppath;

my ($scount, $stotal) = (0, scalar @tfpath);
my ($termsz) = $option{p_progr} ? get_terminal_width : undef;

create_directories ($tfroot, @tdpath) unless $option{s_simul};

for my $source (@tfpath)
{
  my $target = $option{s_simul} ? $bitbucket : $cppath{$source};

  if ($option{t_bench})
  {
    test_buffers($scount, $stotal, $source, $target, $fdtype, $termsz);
  }
  else
  {
    copy_file(++$scount, $stotal, $source, $target, $fdtype, $termsz);
  }
}

exit $ALLOK;


####[ subroutines ]#######################################################################


sub init
{
  $SIG{TERM} = $SIG{INT} = $SIG{QUIT} = $SIG{HUP} = sub { sigtrap }; # LOL

  load_modules 1, \%bootstrp_module;
  parse_options \%option;  

  if ($option{o_color}) 
  {
    show_themes if $option{o_color} =~ /$LSCOL/i;
    set_theme $option{o_color};
  }

  if ($option{v_debug} > 1)
  {
    printf "$/%s$/$/", 
      color($PVSTR, $theme{header});
    show_options;
  }  
}

sub sigtrap
{
  select \*STDOUT; print spectralchars "$/$/it's a trap$/$/";
  exit $ONOES;
}

sub colormebadd ($$)
{
  my ($str, $clr) = @_;

  my ($fgc, $bgc) = map 
  { 
    (defined) ? (uc) : "" 
  } 
  ${$clr}{fg}, ${$clr}{bg};

  $bgc = $COLOR{$bgc || $fgc || "RESET"};
  $fgc = $COLOR{$fgc || "RESET"};

  return $fgc->($bgc->($str));
}

sub color ($$)
{
  my ($str, $clr) = @_;
  return $COLOR{RESET}->(colormebadd ($str, $clr));
}

sub spectralchars ($)
{
  my $str = shift @_;

  # do not use the background colors or the underlined styles 
  @_ = grep { not /on_|^U/i } keys %COLOR;

  # do not use black colors because consoles typically have black colored backgrounds
  @_ = grep { not /black/i } @_;

  return join '', map 
    { 
      colormebadd $_, 
      { 
        fg => $_[int(rand(@_))], 
        bg => undef 
      }
    } split //, $str;
}

sub show_themes
{
  printf "%s$/", color "available themes:", $theme{header};
  printf "  %s$/", color lc $_, $theme{detail} for sort keys %THEME;
  print $/;
  exit $ALLOK;
}

sub set_theme ($)
{
  my $name = lc shift; chomp $name;

  if (exists $THEME{$name})
  {
    %theme = %{$THEME{$name}}
  }
  else
  {
    %theme =
    ( 
      # sub colormebadd ($$$) handles these undefs gracefully
      header => { fg => undef, bg => undef },
      detail => { fg => undef, bg => undef },
      symbol => { fg => undef, bg => undef },  
    );
  }
}

sub print_message ($@)
{
  my ($ret, @msg) = @_;

  if ($ret == $GINFO)
  {
    my $pro = shift @msg;
    printf STDOUT "%s$/  %s$/$/", 
      color($pro, $theme{header}), 
      join "$/  ", map { color $_, $theme{detail} } @msg; 
  }
  elsif ($ret == $NOTIC)
  {
    my $pro = shift @msg;
    printf STDOUT "%s$/  %s$/$/", 
      color($pro, $theme{header}),
      join "$/  ", map { color $_, $theme{detail} } @msg
        if $option{v_debug} > 1;
  }
  elsif ($ret == $WARNG)
  {
    printf STDERR "%s$/  %s$/$/", 
      color("warning:", $theme{header}), 
      join "$/  ", map { color $_, $theme{detail} } @msg;
  }
  elsif ($ret == $ERROR)
  {
    printf STDERR "%s$/  %s$/$/", 
      color("error:", $theme{header}),     
      join "$/  ", map { color $_, $theme{detail} } @msg;
    exit $ONOES;
  }
  else
  {
    printf STDERR "[%s]$/  %s$/$/", 
      color("$0:", $theme{header}),     
      join "$/  ", map { color $_, $theme{detail} } @msg;
  }
}

sub load_modules ($$)
{
  my ($req, $mod) = @_;

  while (my ($pkg, @sym) = map { (ref) ? @{$_} : $_ } each %{$mod})
  {
    my $msg = undef; # don't forget to reset every iteration!

    if (eval "require $pkg; 1")
    {
      foreach (@sym)
      {
        $msg = "export not found: $pkg\:\:$_" and last
          unless eval "$pkg->import('$_'); 1";
      }
    }
    else
    {
      $msg = "module not found: $pkg";
    }

    if (defined $msg)
    {
      delete $$mod{$pkg} if $req == $OPTMO;

      ( sub { print_message $NOTIC, "notice:", shift },
        sub { print_message $ERROR,            shift }, )[$req == $REQMO]->($msg);
    }
  }
}

sub show_modules ($$$)
{
  my ($req, $gid, %mod) = (shift, shift, %{(shift)});

  my $wid = 0;
  (length(color($_, $theme{detail})) > $wid) 
    && 
  ($wid = length(color($_, $theme{detail})))
    for keys %mod;

  printf "%s$/",
    color(
      sprintf("%s %smodules:", 
        $req == $REQMO ? "required" : "optional",
        defined $gid ? $gid . " " : ""), 
      $theme{header});
  
  printf "  %${wid}s$/$/", 
    color("none", $theme{detail}) and return 
      unless keys %mod > 0;

  while (my ($pkg, @sym) = map { (ref) ? @{$_} : $_ } each %mod)
  {
    printf "  %${wid}s%s%s%s%s$/", 
      color($pkg,       $theme{detail}),
      color(' => ',     $theme{symbol}),
      color('[',        $theme{symbol}),
      color(@sym ? 
        " @sym " : "",  $theme{detail}),
      color(']',        $theme{symbol});
  }
  print $/;
}

sub parse_options ($)
{
  my $opt = shift;

  Getopt::Long::Configure('bundling');

  # override SIGWARN to make Getopt shut up
  {
    local $SIG{__WARN__} = sub { }; # do nothing

    Getopt::Long::GetOptions
    (
      eval join ',',
        map 
        { 
          '${$$opt{'.$_.'}}[0] => \${$$opt{'.$_.'}}[1]' 
        } 
        keys %{$opt}
    )
    or print_message $ERROR, 'wat? see --usage for more information';
  }

  $$opt{$_} = ${$$opt{$_}}[1] 
    for keys %{$opt};
}

sub show_options
{
  if ($option{v_debug} > 1)
  {
    printf "%s$/", 
      color("command-line options:", $theme{header});

    while (my ($k, $v) = each %option) 
    { 
      printf "  %s%s%-s$/", 
        color($k,    $theme{detail}), 
        color(' = ', $theme{symbol}),
        color($v,    $theme{detail}); 
    }
    printf "     %s%s%s%-s%s$/$/", 
      color('args',      $theme{detail}), 
      color(' = ',       $theme{symbol}),
      color('(',         $theme{symbol}),
      join(color(', ',   $theme{symbol}), 
        map { color $_,  
          $theme{detail} } @ARGV),
      color(')',         $theme{symbol});
  }  
}

sub configure
{
  $option{p_progr} = !!($option{p_progr} and not $option{q_quiet});

  $bitbucket = File::Spec->devnull; # UNIX: /dev/null

  $option{c_cksum} = get_hash_function;

  print_message $ERROR, 
    "module not found: Benchmark is required for I/O buffer tests"
      unless not $option{t_bench} or exists $optional_module{'Benchmark'};

# DISABLED FOR NOW - the larger buffers seem to perform much MUCH better than the 
# preferred page size reported by sysconf in the _SC_PAGESIZE field
if (0)
{
  # ask the POSIX layer for a preferred page size for the I/O operations
  if ($option{b_buffs} == $INVAL)
  {
    if (exists $optional_module{'POSIX'})
    {
      $option{b_buffs} = POSIX::sysconf(&POSIX::_SC_PAGESIZE);
    }
    else
    {    
      print_message $WARNG, 
        "module not found: POSIX: using buffer size $defbuff bytes";
      $option{b_buffs} = $defbuff;
    }
  }
}

  print_message $WARNG, 
    "specified buffer too small: $option{b_buffs}: using $defbuff bytes"
      and $option{b_buffs} = $defbuff unless $option{b_buffs} > 0;

  print_message $WARNG, 
    "specified buffer too large: $option{b_buffs}: using $defbuff bytes"
      and $option{b_buffs} = $defbuff unless $option{b_buffs} < 0x7FFFFFFF;

  print_message $NOTIC, "notice:", 
    "enabling --force for benchmarking tests"
      if $option{t_bench} and not $option{f_force} and $option{f_force} = 1;  
}

sub pod ($$)
{
  Pod::Usage::pod2usage
  ({ 
    -exitval => $_[0], 
    -verbose => $pod{$_[1]}, 
  }) 
  if defined $pod{$_[1]};
}

sub identify_paths (@)
{
  if ($option{v_debug} > 1)
  {
    show_modules $REQMO, "bootstrap", \%bootstrp_module;
    show_modules $REQMO, "feature", \%required_module;
    show_modules $OPTMO, "feature", \%optional_module;
  }
    
  print_message $ERROR, 
    "required source and target files not provided (try --manpage)"
      unless @_ > 1;

  my ($target, @source, $fdtype, %unique) = shift @_;

  @source = grep { -e } @_; # filter out the nonexistent source files

  print_message $ERROR, 
    "no valid source files provided"
      unless @source > 0;

  # determine the target file type (file or directory)
  $fdtype = ($FTYPE, $DTYPE)

    # destination is a directory if any of the following OR conditions are true:
    [ 
        # more than one source file specified (not necessarily existing files)
        @_ > 1 
      || 
        # specified file is a directory -OR- specified name has a trailing slash
        (-d $target || $target =~ /\/$/) # TODO: fix me for non-unix filepaths
      || 
        # the specified source file is a directory
        (grep { -e && -d } @_) > 0 
    ];

  $target =~ s/\/$//; # TODO: fix me for non-unix filepaths

  print_message $ERROR, 
    "target must be a directory when copying a directory or more than one file" 
      if $fdtype == $DTYPE and -f $target;  

  #
  # the { key => val } structure of a hash is perfect for defining primitive copy
  # operations, where key is a source file path and val is the destination path
  # 
  # both %cppath and the below @dstack are declared global with "our" to provide
  # visibility from within File::Find
  #
  our %cppath = ();

  if ($fdtype == $DTYPE)
  {
    our @dstack = ( $target );

    { # File::Find is remarkably noisy
      no warnings; 

      sub preprocess 
        { push @dstack, (File::Spec->splitpath($File::Find::dir))[$FILIX]; @_ }

      sub postprocess 
        { pop @dstack }

      sub wanted 
      { 
        my $cfname = (File::Spec->splitpath($File::Find::name))[$FILIX];
        $cppath{$File::Find::name} = File::Spec->catfile(@dstack, $cfname);
      }

      my %findop =
      (
        preprocess   => \&preprocess,
        postprocess  => \&postprocess,
        wanted       => \&wanted,
        follow       => 0,
        no_chdir     => 0,       
      );

      File::Find::find(\%findop, @source);
    }
  }
  else
  {
    # if target is a file, we only have a single copy operation
    $cppath{pop @source} = $target;
  }

  # show the selected files and their destination if elevated --verbose
  if ($option{v_debug} > 1)
  {
    my $wsppad = "" .    ("      " x ((grep { -e && -d } keys %cppath) > 0));
    sub tag ($)
    {
      sprintf '%s%s%s',
        color('(',     $theme{symbol}),
        color((shift), $theme{header}),
        color(')',     $theme{symbol})
    }
    sub nprefix ($$) { $_[0] ? tag("DIR")." " : $_[1] }
    sub nsuffix ($$) { $_[0] ? " ".tag("NEW") : $_[1] }

    # shows precisely the source and target file paths for every source file
    if ($option{v_debug} > 2)
    {
      printf "%s$/", 
        color('copy operations:', $theme{header});

      printf "  %s%-s$/%*s%s%s%s$/$/", 
        nprefix((-d $_),    $wsppad), 
        color($_,           $theme{detail}), 
        4, " ", 
        $wsppad, 
        color('-=> ',       $theme{symbol}),
        color($cppath{$_},  $theme{detail})
          for sort keys %cppath;
    }
    # shows a list of source files and the target file/directory
    else
    {
      printf "%s$/  %s$/$/", 
        color('source files:', $theme{header}),
        join("$/  ", map { 
          nprefix((-d $_), $wsppad) . color($_, $theme{detail}) } 
            sort keys %cppath);
        
      printf "%s$/  %s%s%s$/$/", 
        color('target file:',      $theme{header}),
        nprefix($fdtype,           $wsppad), 
        color($target,             $theme{detail}),
        nsuffix(not (-e $target),  $wsppad);
    }
  }

  return 
    $fdtype, 
    $fdtype == $DTYPE 
      ? $target 
      : (File::Spec->splitpath($target))[$DIRIX] || ".", 
    %cppath;
}

sub create_directories (@)
{
  foreach my $directory (@_)
  {
    print_message $ERROR, 
      "cannot create directory: $directory: $!"
        unless -d $directory or File::Path::mkpath($directory);
    print_message $ERROR, 
      "invalid path: cannot write to directory: $directory"
        unless -w $directory;
  }
}

sub copy_file ($$$$$$)
{
  my ($scount, $stotal, $source, $target, $fdtype, $termsz) = @_;

  $termsz = $termsz < $PCTGW ? $PCTGW : $option{w_width} if $option{w_width};

  my $cwidth = int(log($stotal) / log(10) + 1); # log10(N)+1 = number of digits in N

  {
    my $read; # source file "read" handle
    my $writ; # target file "write" handle
    my $buff; # byte buffer

    my @sfstat = stat $source;
    my @tfstat = stat $target;

    if (-f $target)
    {
      print_message $ERROR, "cannot copy: source and target are the same file"
        if $sfstat[$STATN{ino}] == $tfstat[$STATN{ino}];
      print_message $ERROR, "cannot copy: file exists: $target (use --force)"
        unless $option{f_force};
    }

    print_message $ERROR, "cannot open file for reading: $source: $!"
      unless open $read, '<', $source;
    print_message $ERROR, "cannot put file in binary mode: $source: $!"
      unless binmode $read;

    print_message $ERROR, "cannot open file for writing: $target: $!"
      unless open $writ, '>', $target;
    print_message $ERROR, "cannot put file in binary mode: $target: $!"
      unless binmode $writ;

    my $fsize = $option{t_bench} ? $defbuff : $option{b_buffs} || $defbuff;
    my $rsize = -s $read || 1000;
    my $wsize = 0;
    my $width = int(log($rsize) / log(10) + 1);
    my $iters = undef;
    my $cperr = undef; 
    my $tinit = undef;
    my $telap = undef;
    my $rotsn = (File::Spec->splitpath($source))[2];
    my $rotln = length $rotsn;

    my $cksta = ${$option{c_cksum}}[$CKSUM] || undef;
    my $ckenc = ${$option{c_cksum}}[$ENCOD] || undef;    
    my $cknam = ${$option{c_cksum}}[$HALGO] || undef;    

    if ($option{t_bench})
    {
      my $tcount = ($scount - 1) % $option{t_bench};

      if ($option{v_debug})
      {
        $iters = sprintf "%s %d %s %d", 
          color('test',            $theme{header}), 
          color($tcount + 1,       $theme{detail}), 
          color('/',               $theme{symbol}), 
          color($option{t_bench},  $theme{detail}); 
      }
      elsif ($tcount == 0)
      {
        $iters = sprintf "%d %s%s%s%s", 
          color($option{t_bench},  $theme{detail}), 
          color('test',            $theme{header}), 
          color('(',               $theme{symbol}), 
          color('s',               $theme{header}), 
          color(')',               $theme{symbol}); 
      }

      printf "%s$/", header("test", 
        $cwidth, $scount, $stotal, $rsize, $fsize, $iters, $source, $target)
          unless not defined $iters;

    }
    elsif ($option{v_debug} )
    {
      printf "%s$/", header("file",
        $cwidth, $scount, $stotal, $rsize, $fsize, undef, $source, $target);
    }    

    $tinit = [Time::HiRes::gettimeofday()];

###########################################################################[ DISK I/O ]>>>
    {
      my ($r, $w, $t) = (0, 0, 0);

      $cperr = sprintf "sysread(): cannot read file: $source: $!" and last
        unless defined ($r = sysread $read, $buff, $fsize);

      last unless $r;

      for ($w = 0; $w < $r; $w += $t)
      {
        $cperr = sprintf "syswrite(): cannot write file: $target: $!" and last
          unless $t = syswrite $writ, $buff, $r - $w, $w;

        $cksta->add($buff) if defined $cksta;

        $wsize += $t;

        if (defined $termsz)
        {
          show_progress($wsize, $rsize, 
            Time::HiRes::tv_interval($tinit), $termsz, \*STDOUT, $rotsn, $rotln);
        }
        else
        {
          if ($option{v_debug} > 2)
          {
            printf "%*s[ %*d / %*d ] ( %6.2f%% )$/", 
              6, "", $width, $wsize, $width, $rsize, $wsize / $rsize * 100.0;
          }
        }
      }

      redo;
    }
###########################################################################[ DISK I/O ]<<<    
    
    $telap = Time::HiRes::tv_interval($tinit);

    if ($wsize > 0 and not $option{t_bench})
    {
      print $/ 
        if $option{v_debug} > 0 and $option{p_progr};

      printf "%s$/", summary($wsize, $telap)
        if $option{v_debug} > 0;

      if (defined $cksta)
      {
        my %digst = 
        (
          bin => sub { (shift)->digest() },
          hex => sub { (shift)->hexdigest() },
          b64 => sub { (shift)->b64digest() },
        );

        printf "%s$/", checksum($cknam, 
          $digst{$ckenc}->($cksta), (File::Spec->splitpath($target))[$FILIX], $ckenc);
      }

      print $/ 
        if $stotal > 1 and $option{p_progr} or $option{v_debug} > 1;
    }

    close $writ;
    close $read;

    print_message $ERROR, $cperr if defined $cperr;
  }
}

sub test_buffers ($$$$$$)
{
  my ($scount, $stotal, $source, $target, $fdtype, $evcode, $termsz) = @_;

  # 
  # define which buffers should be tested (in 1 byte units)
  #
  @_ = 
  (
    #1024 ** 0             ,# 1.00 B   =           1 byte
    #1024 ** 1 / 4         ,# 0.25 KiB =         256
    #1024 ** 1 / 2         ,# 0.50 KiB =         512
    #1024 ** 1             ,# 1.00 KiB =        1024
    1024 ** 2 / 4         ,# 0.25 MiB =      262144
    1024 ** 2 / 3.2       ,# 0.31 MiB =      327680
    1024 ** 2 / 2.048     ,# 0.49 MiB =      512000
    1024 ** 2 / 2         ,# 0.50 MiB =      524288
    1024 ** 2 / 1.6       ,# 0.63 MiB =      655360
    1024 ** 2 / 1.31072   ,# 0.76 MiB =      800000
    1024 ** 2 / 1.024     ,# 0.98 MiB =     1024000
    1024 ** 2             ,# 1.00 MiB =     1048576
    #1024 ** 3 / 4         ,# 0.25 GiB =   268435456
    #1024 ** 3 / 2         ,# 0.50 GiB =   536870912
    #1024 ** 3             ,# 1.00 GiB =  1073741824
  );

  $stotal = $stotal * $option{t_bench} * scalar @_; 

  $evcode = 
    "copy_file(++\$scount, $stotal, \"$source\", \"$target\", $fdtype, \$termsz)";

  cmpthese($option{t_bench}, { map {("[ $_ B ]" => "\$defbuff = $_; $evcode")} @_ });
}

sub executable_path ($)
{
  my $name = shift @_;
  my @path =  map { Cwd::realpath($_) }
             grep { -f "$_" && -x _   } 
              map { File::Spec->catfile($_, $name) } split /:/, $ENV{PATH};

  return @path;
}

sub execute_system_program ($$$)
{
  my ($name, $args, $evre) = @_;

  my @line = ();

  foreach (executable_path $name)
  {
    next unless open my $read, '-|', "\"$_\" $args";

    @line = grep { $evre } <$read>; close $read; chomp @line;
    
    scalar @line > 0 and last or @line = ();
  }

  print_message $WARNG,
    "no expected values returned from system command: `$name $args`"
      unless scalar @line > 0;

  return @line;
}

sub get_terminal_width
{
  my ($wchar, $hchar, $wpixl, $hpixl) = (0, 0, 0, 0);

  my @srval = ();

  # width specified manually
  if (exists $optional_module{'Term::ReadKey'})
  {
    ($wchar, $hchar, $wpixl, $hpixl) = @_ 
      if 0 < scalar (@_ = Term::ReadKey::GetTerminalSize());
  }
  # and finally start querying the system tools
  else
  {
    if (0 < scalar (@srval = execute_system_program
        'tput', 
        'cols',
        qr|^\s*\d+\s*$|))
    {
      ($wchar) = @srval;
    }
    elsif (0 < scalar (@srval = execute_system_program
        'stty', 
        '-a | sed -ne \'s/^.*columns\s*\([0-9]*\);.*$/\1\n/p\'',
        qr|^\s*\d+\s*$|))
    {
      ($wchar) = @srval;
    }
    else
    {
      $wchar = $DEFTW;
    }
  }

  return $wchar;
}

sub show_progress ($$$$$$$)
{
  my ($bw, $bt, $es, $tw, $fh, $sr, $sl) = @_;

  my $cf = select($fh); 
       $_= $|; 
       $|=  1;
       $|= $_;
       select($_);

  my $cr = $bw / $bt;      # completion ratio  
  my $pr = int($cr * 100); # percent complete

  printf $fh "\r%s", status($tw, $cr, $pr);

  # STDOUT gets closed after flush, so we need to reopen it for our caller
  select \*STDOUT if defined $termsz;
}

sub header (@)
{
  my ($title, $width, $count, $total, $rsize, $fsize, $iters, $srcfn, $dstfn) = @_;

  return 
    sprintf "%s%s%s%s%s%s%s%s%s%s%s",
      color('[',          $theme{symbol}),
      color(" $title ",   $theme{header}),
      color($count,       $theme{header}),
      color(' / ',        $theme{symbol}),
      color($total,       $theme{header}),
      color(' ] ',        $theme{symbol}),
      color($srcfn,       $theme{detail}),
      color(' (',         $theme{symbol}),
      color($rsize,       $theme{detail}),
      color(' bytes',     $theme{header}),
      color(')',          $theme{symbol}),
}

sub status (@)
{
  my ($tw, $cr, $pr) = @_;

# percentage window
  my $pw = 
    sprintf '%s%s%s', 
      color('[', $theme{symbol}), 
      color(
        sprintf("%*s", 
                $PCTGW - 2, # -2 for symbols [] in e.g. "[ 42%]"
                "$pr%"), 
        $theme{header}), 
      color(']', $theme{symbol});


  # determine if we have room for the progress bar
  my $as = $tw - $PCTGW; # remaining char space for progress bar

  $as = $as < $PBARW ? 
              0 : # hide the progress bar if we don't have the minimum chars required
        $as - 2 ; # otherwise, we have room. subtract -2 chars for "[]"

  my $ni = int($cr * $as); # progress symbol count  
  
  # progress window
  my $nw = 
    sprintf '%s%s%s', 

      color('[', $theme{symbol}), 
      color(      
        sprintf("%-*s", 
                $as, 
                $as > 0 ? ($PROGS x $ni) . (' ' x ($as - $ni)) : ''),
        $theme{detail}),
      color(']', $theme{symbol});

  return 
    sprintf "%-*s%s", 
      $as, 
      $as > 0 ? $nw : '', 
      $pw;
}

sub summary (@)
{
  my ($wrote, $elaps) = @_;

  return 
    sprintf "%s%s%s%s%s%s%s%s%s%s%s%s", 
      color('[ ',                     $theme{symbol}),
      color($wrote,                   $theme{detail}),
      color(" bytes",                 $theme{header}),
      color(" / ",                    $theme{symbol}),
      color(sprintf("%.6f", $elaps),  $theme{detail}),
      color(" seconds",               $theme{header}),
      color(" (",                     $theme{symbol}),
      color(int($wrote / $elaps),     $theme{detail}),
      color(" B",                     $theme{header}),
      color("/",                      $theme{symbol}),
      color("s",                      $theme{header}),
      color(") ]",                    $theme{symbol}),
}

sub checksum (@)
{
  my ($cksum, $digst, $dstfn, $ckenc) = @_;

  return
    sprintf "%s%s%s%s%s%s",
      color($digst,  $theme{detail}),
      color(" - ",   $theme{symbol}),
      color($dstfn,  $theme{detail}),
      color(" (",    $theme{symbol}),
      color($cksum,  $theme{header}),
      color(")",     $theme{symbol}),
}

sub get_hash_function
{
  return undef unless $option{c_cksum};

  my ($OX, $NX) = 0 .. 1;

  my %s =
  (
       md5 => [ sub { Digest::MD5->new()    }, "MD5"     ],
      sha1 => [ sub { Digest::SHA->new(1)   }, "SHA-1"   ],
    sha224 => [ sub { Digest::SHA->new(224) }, "SHA-224" ],
    sha256 => [ sub { Digest::SHA->new(256) }, "SHA-256" ],
    sha384 => [ sub { Digest::SHA->new(384) }, "SHA-384" ],
    sha512 => [ sub { Digest::SHA->new(512) }, "SHA-512" ],
  );

  my ($h, $e) = map { lc } split '-', $option{c_cksum};

  if (exists $s{$h})
  {
    $e ||= $DEENC;

    if ($e !~ /^(bin|hex|b64)$/i)
    {
      print_message $WARNG,
        sprintf "unrecognized encoding: %s: using %s", $e, $DEENC;

      $e = $DEENC;
    }

    return [ ${$s{$h}}[$OX]->(), $e, ${$s{$h}}[$NX] ];
  }
  else
  {
    print_message $ERROR,
      "unrecognized hash function: $option{c_cksum} (try --manpage)";
  }
}


####[ INTERPRETER BLOCKS ]################################################################


END
{
  print color "", undef; # reset colors
}


__END__


####[ POD ]###############################################################################

=head1 NAME

=over 4

=item B<pcp> -- Copy files and directories with progress indicators, checksum validations, and some other stuff

=back

=head1 SYNOPSIS

B<pcp> [ options ] [ B<-?bcdfhimopqrsuvw> ] F<source-file> F<target-file>

B<pcp> [ options ] [ B<-?bcdfhimopqrsuvw> ] F<source-file> F<...> F<target-directory>

=head1 DESCRIPTION

B<pcp> will copy a set of files or directories from one location to another, and it can display a real-time progress indicator with checksum details of the resulting copy operation.

The program does not currently support asynchronous I/O, so copy operations from one disk to another may be stupid slow.

=head1 OPTIONS

=over 8

=item B<--buffer=>F<bytes>, B<-b> F<bytes>

Read and write F<bytes> of data during the copy operation. The default buffer size is B<500 KiB> (B<512 KB>).

=item B<--checksum=>F<hash>, B<-c> F<hash>

Print checksum of copied file using hash function F<hash>. The following functions are available:

    md5    = MD5
    sha1   = SHA-1
    sha224 = SHA-224
    sha256 = SHA-256
    sha384 = SHA-384 (system must support 64-bit types)
    sha512 = SHA-512 (system must support 64-bit types)

To specify the encoding used for the digest output, append '-bin' for binary, '-hex' for hexadecimal, or '-b64' for Base64. If no encoding is specified, then hexadecimal encoding is used.

For example, passing option "B<--checksum=>F<sha1-b64>" will compute the SHA-1 digest in Base64 format.

=item B<--crc=>F<bits>, B<-r> F<bits>

(B<not implemented>) Perform a cyclic redundancy check (CRC) with a check value of size F<bits>.

=item B<--depth=>F<depth>, B<-d> F<depth>

(B<not implemented>) When copying a directory, do not copy files more than F<depth> levels deep.

=item B<--force>, B<-f>

(B<default>) Force copy even if destination file already exists. Use B<--noforce> to disable.

=item B<--help>, B<--usage>, B<--wat>, B<-h>, B<-u>, B<-w>, B<-?>

Print synopsis and options to STDOUT and exit.

=item B<--interactive>, B<-i>

(B<not implemented>) Before performing each file copy, prompt the user for approval.

=item B<--manpage>, B<-m>

Display the manual page and exit.

=item B<--colors=>F<name>, B<--theme=>F<name>, B<-o> F<name>

Set the program colors theme to F<name>. If F<name> is B<list>, then print a list of available themes and exit.

=item B<--progress>, B<-p>

(B<default>) Use visual indicator to show progress of copy operation. Currently uses a progress bar, but a sweet ASCII graphic of a shark attacking a man is in work. Use B<--noprogress>, B<--quiet>, or B<-q> to disable.

=item B<--quiet>, B<-q>

Disable progress indicator. This is a synonym for B<--noprogress>. 

=over 4

B<NOTE>: This option does not suppress all output. The B<--verbose> and B<--test> options do not give a shit and will keep running their mouth if enabled.

=back

=item B<--simulate>, B<-s>

Do not actually perform the copy operation, but print to STDOUT the operations that would be performed instead (UNIX: writes to F</dev/null>).

=item B<--test=>F<iterations>, B<-t> F<iterations>

Requires F<Benchmark> (Perl 5 core module). Performs F<iterations> copy operations for each of the following buffer sizes:

   262144 bytes = 0.25 MiB
   327680 bytes
   512000 bytes <- default
   524288 bytes = 0.50 MiB
   655360 bytes
   800000 bytes
  1024000 bytes
  1048576 bytes = 1.00 MiB

The F<Benchmark> module then prints a nice comparison table detailing the I/O performance of each buffer.

=item B<--debug>, B<--verbose>, B<-d>, B<-v>

Print verbose debug information (additional flags increases level of detail).

=item B<--width=>F<width>, B<-w> F<width>

Use a terminal width with length F<width> chars. Only the status line will span precisely F<width> chars (again, the B<--verbose> and B<--test> options do not give a shit).

=back

=cut
